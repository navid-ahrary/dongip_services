"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const debugFactory = require("debug");
const component_1 = require("./component");
const keys_1 = require("./keys");
const lifecycle_1 = require("./lifecycle");
const lifecycle_registry_1 = require("./lifecycle-registry");
const debug = debugFactory('loopback:core:application');
/**
 * Application is the container for various types of artifacts, such as
 * components, servers, controllers, repositories, datasources, connectors,
 * and models.
 */
class Application extends context_1.Context {
    constructor(configOrParent, parent) {
        super(configOrParent instanceof context_1.Context ? configOrParent : parent, 'application');
        if (configOrParent instanceof context_1.Context)
            configOrParent = {};
        this.options = configOrParent || {};
        // Bind the life cycle observer registry
        this.bind(keys_1.CoreBindings.LIFE_CYCLE_OBSERVER_REGISTRY)
            .toClass(lifecycle_registry_1.LifeCycleObserverRegistry)
            .inScope(context_1.BindingScope.SINGLETON);
        // Bind to self to allow injection of application context in other modules.
        this.bind(keys_1.CoreBindings.APPLICATION_INSTANCE).to(this);
        // Make options available to other modules as well.
        this.bind(keys_1.CoreBindings.APPLICATION_CONFIG).to(this.options);
    }
    /**
     * Register a controller class with this application.
     *
     * @param controllerCtor - The controller class
     * (constructor function).
     * @param name - Optional controller name, default to the class name
     * @returns The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * @example
     * ```ts
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     */
    controller(controllerCtor, name) {
        debug('Adding controller %s', name || controllerCtor.name);
        const binding = context_1.createBindingFromClass(controllerCtor, {
            name,
            namespace: keys_1.CoreBindings.CONTROLLERS,
            type: keys_1.CoreTags.CONTROLLER,
            defaultScope: context_1.BindingScope.TRANSIENT,
        });
        this.add(binding);
        return binding;
    }
    /**
     * Bind a Server constructor to the Application's master context.
     * Each server constructor added in this way must provide a unique prefix
     * to prevent binding overlap.
     *
     * @example
     * ```ts
     * app.server(RestServer);
     * // This server constructor will be bound under "servers.RestServer".
     * app.server(RestServer, "v1API");
     * // This server instance will be bound under "servers.v1API".
     * ```
     *
     * @param server - The server constructor.
     * @param name - Optional override for key name.
     * @returns Binding for the server class
     *
     */
    server(ctor, name) {
        debug('Adding server %s', name || ctor.name);
        const binding = context_1.createBindingFromClass(ctor, {
            name,
            namespace: keys_1.CoreBindings.SERVERS,
            type: keys_1.CoreTags.SERVER,
            defaultScope: context_1.BindingScope.SINGLETON,
        }).apply(lifecycle_1.asLifeCycleObserver);
        this.add(binding);
        return binding;
    }
    /**
     * Bind an array of Server constructors to the Application's master
     * context.
     * Each server added in this way will automatically be named based on the
     * class constructor name with the "servers." prefix.
     *
     * @remarks
     * If you wish to control the binding keys for particular server instances,
     * use the app.server function instead.
     * ```ts
     * app.servers([
     *  RestServer,
     *  GRPCServer,
     * ]);
     * // Creates a binding for "servers.RestServer" and a binding for
     * // "servers.GRPCServer";
     * ```
     *
     * @param ctors - An array of Server constructors.
     * @returns An array of bindings for the registered server classes
     *
     */
    servers(ctors) {
        return ctors.map(ctor => this.server(ctor));
    }
    /**
     * Retrieve the singleton instance for a bound server.
     *
     * @typeParam T - Server type
     * @param ctor - The constructor that was used to make the
     * binding.
     * @returns A Promise of server instance
     *
     */
    async getServer(target) {
        let key;
        // instanceof check not reliable for string.
        if (typeof target === 'string') {
            key = `${keys_1.CoreBindings.SERVERS}.${target}`;
        }
        else {
            const ctor = target;
            key = `${keys_1.CoreBindings.SERVERS}.${ctor.name}`;
        }
        return this.get(key);
    }
    /**
     * Start the application, and all of its registered observers.
     */
    async start() {
        const registry = await this.getLifeCycleObserverRegistry();
        await registry.start();
    }
    /**
     * Stop the application instance and all of its registered observers.
     */
    async stop() {
        const registry = await this.getLifeCycleObserverRegistry();
        await registry.stop();
    }
    async getLifeCycleObserverRegistry() {
        return this.get(keys_1.CoreBindings.LIFE_CYCLE_OBSERVER_REGISTRY);
    }
    /**
     * Add a component to this application and register extensions such as
     * controllers, providers, and servers from the component.
     *
     * @param componentCtor - The component class to add.
     * @param name - Optional component name, default to the class name
     *
     * @example
     * ```ts
     *
     * export class ProductComponent {
     *   controllers = [ProductController];
     *   repositories = [ProductRepo, UserRepo];
     *   providers = {
     *     [AUTHENTICATION_STRATEGY]: AuthStrategy,
     *     [AUTHORIZATION_ROLE]: Role,
     *   };
     * };
     *
     * app.component(ProductComponent);
     * ```
     */
    component(componentCtor, name) {
        debug('Adding component: %s', name || componentCtor.name);
        const binding = context_1.createBindingFromClass(componentCtor, {
            name,
            namespace: keys_1.CoreBindings.COMPONENTS,
            type: keys_1.CoreTags.COMPONENT,
            defaultScope: context_1.BindingScope.SINGLETON,
        });
        if (lifecycle_1.isLifeCycleObserverClass(componentCtor)) {
            binding.apply(lifecycle_1.asLifeCycleObserver);
        }
        this.add(binding);
        // Assuming components can be synchronously instantiated
        const instance = this.getSync(binding.key);
        component_1.mountComponent(this, instance);
        return binding;
    }
    /**
     * Set application metadata. `@loopback/boot` calls this method to populate
     * the metadata from `package.json`.
     *
     * @param metadata - Application metadata
     */
    setMetadata(metadata) {
        this.bind(keys_1.CoreBindings.APPLICATION_METADATA).to(metadata);
    }
    /**
     * Register a life cycle observer class
     * @param ctor - A class implements LifeCycleObserver
     * @param name - Optional name for the life cycle observer
     */
    lifeCycleObserver(ctor, name) {
        debug('Adding life cycle observer %s', name || ctor.name);
        const binding = context_1.createBindingFromClass(ctor, {
            name,
            namespace: keys_1.CoreBindings.LIFE_CYCLE_OBSERVERS,
            type: keys_1.CoreTags.LIFE_CYCLE_OBSERVER,
            defaultScope: context_1.BindingScope.SINGLETON,
        }).apply(lifecycle_1.asLifeCycleObserver);
        this.add(binding);
        return binding;
    }
    /**
     * Add a service to this application.
     *
     * @param cls - The service or provider class
     *
     * @example
     *
     * ```ts
     * // Define a class to be bound via ctx.toClass()
     * @bind({scope: BindingScope.SINGLETON})
     * export class LogService {
     *   log(msg: string) {
     *     console.log(msg);
     *   }
     * }
     *
     * // Define a class to be bound via ctx.toProvider()
     * const uuidv4 = require('uuid/v4');
     * export class UuidProvider implements Provider<string> {
     *   value() {
     *     return uuidv4();
     *   }
     * }
     *
     * // Register the local services
     * app.service(LogService);
     * app.service(UuidProvider, 'uuid');
     *
     * export class MyController {
     *   constructor(
     *     @inject('services.uuid') private uuid: string,
     *     @inject('services.LogService') private log: LogService,
     *   ) {
     *   }
     *
     *   greet(name: string) {
     *     this.log(`Greet request ${this.uuid} received: ${name}`);
     *     return `${this.uuid}: ${name}`;
     *   }
     * }
     * ```
     */
    service(cls, name) {
        if (!name && context_1.isProviderClass(cls)) {
            // Trim `Provider` from the default service name
            // This is needed to keep backward compatibility
            const templateFn = context_1.bindingTemplateFor(cls);
            const template = context_1.Binding.bind('template').apply(templateFn);
            if (template.tagMap[context_1.ContextTags.PROVIDER] &&
                !template.tagMap[context_1.ContextTags.NAME]) {
                // The class is a provider and no `name` tag is found
                name = cls.name.replace(/Provider$/, '');
            }
        }
        const binding = context_1.createBindingFromClass(cls, {
            name,
            type: 'service',
        });
        this.add(binding);
        return binding;
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map